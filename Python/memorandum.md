# PythonでOthelloAIを実装する
# Othelloで対戦できる環境を1から作成する

## Serverの仕様
- python othello_server.py <ポート番号> で対戦のためのポート番号を指定する

## Serverの実装方針
- まず初期化する
    - グローバル変数(Boardなど)を作成する
- threadを3つ立てる
    - 対戦を管理するserver0と、対戦者と通信するserver1/2を動かす
- server0について
    - playerと通信できるようになったら処理をスタートする
    - 対戦が開始したら先行後攻をランダムに決めてplayerに連絡する(先攻には1、後攻には0を送る)
    - 対戦が終了したらplayerに勝敗と石の数をまとめて結果として送る(勝敗を表す1dと黒石、白石をそれぞれ2dずつ、計5dを送る)
    - 対戦中は送信されてきた手が妥当かどうか判定し、妥当であればそれをplayerに送信する
        - 手を打ったplayerには100を加えて返す
        - 手を打たれたplayerにはそのまま送信する
    - 仕事が終わったらserver1/2が動けるようにグローバル変数の値を更新する
- 複数回対戦を実現するためにはmain関数内でwhileループを回して、初期化->スレッド建設->スレッド削除->後処理を繰り返す
    - serverに関する設定の読み込みは一度だけ行えば良い
    - clientに関する設定があればそれは通信が開始される際に行えば良い

TODO: この流れで実装し直す
1対戦の管理に必要な前処理を行う(e.g. 試合数などの設定情報を読み込む)
-> 通信はこの時点でつくっておく
while True:
    1試合の管理に必要な前処理を行う(e.g. 変数を初期化する)
    while True:
        STARTならば先攻に手を促す
        ENDならば両者をとめて結果発表し、break
        どちらでもなければ手を選んでもらい、相手にも伝達する
    1試合のあとで必要な後処理を行う
    設定した試合数に達していればbreak
全ての後処理を行う(e.g. 対戦結果を発表し、通信を切断する)
    

## Server内のglobal変数
- B, C, M
    - boardの状態や(送信されてきた)手を格納する
- HOST, PORT, SERVER
    - host名、port番号、通信に使うソケットを定義する(基本的に1回しか設定しない)
- REFEREE, PLAYER1, PLAYER2
    - 通信に使うソケットを定義する(REFEREEは使ってない)
- COLOR_OF_PLAYER, PLAYER_OF_COLOR
    - playerとcolorを対応づける
- REF, PLY1, PLY2
    - server0-2が動作するためのスイッチの役割をする
- START, END
    - 対戦が開始・終了したことを示すフラグである(複数対戦になったらより多くの変数が必要になりそう)

## CLientの仕様
- python othello_client.py <ホスト名> <ポート番号> でServerが立っているポートなどを指定することで対戦できる

## Clientの実装方針
- まず初期化する
- 基本的にどちらの番でも通信は行う
    - 自分の番であれば打ちたい手をエンコードして送信する
    - 相手の番であれば受信したものをそのまま返す
- 受信して、盤面を動かし、(自分の番であれば手を考えて、)送信する
- Clientで表示されているオセロ盤のcolorはblackがx、whiteがoになっている


